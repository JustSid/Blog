+++
title = "Porting X-Plane to Vulkan and Metal Part #1 - Why bother porting a 20+ year old OpenGL engine?"
date = 2020-01-18T00:00:00+00:00
categories = ["Development", "VIM"]
tags = [ "x-plane", "vulkan", "metal"]
slug = "porting-xplane-part1"
draft = true
+++

This is part 1 of many blog posts detailing basically what I've been up to for the past 2 years. As the title implies, it was porting the engine powering [X-Plane](https://x-plane.com), a professional flight simulator that is currently in version 11 and ships on Windows, macOS and Linux. During the porting effort we shipped 3 large feature and content updates, as well as a ton of smaller bug fix updates. If that doesn't sound exciting enough of a task, we also maintained backwards compatibility for most OpenGL based third party plugins in the modern Vulkan and Metal backends.

In this first post I want to briefly touch on the motivation of porting X-Plane, as well as the broad challenges we were facing and why we wanted to do the port in the first place. The project was underway for 2 years and was mainly done by Ben Supnik (project manager of X-Plane desktop as well as the main graphics guy) and me the "Vulkanologist" at Laminar Research. Of course the rest of the Laminar Research team, while maybe not directly involved in slinging Vulkan and Metal code, were nothing but supportive in our endeavour and are all around great people. Shout out in particular to Tyler Young (who runs our CI and test infrastructure, as well as knows the answers to just about anything related to the codebase), Stefan Riemens (who rewrote a bunch of our shaders and ported a bunch of other misc code) and of course Jennifer Roberts (who does QA amongst a ton of other things).

## Motivation and history

In early 2018, all we had was the legacy X-Plane graphics engine that had grown over the past 20 odd years. And by graphics engine, I mean that we had a bunch of classes to abstract away more complex GL behaviour. Things such as a shader class, a class to handle geometry, an emulation layer for immediate mode rendering that streamed geometry. The typical stuff. Then, we had a ton of OpenGL state whacking all over the codebase. There was no big abstraction over the graphics bits, you either called into one of the helper classes or just called OpenGL directly. Basically, the graphics pieces of X-Plane had grown over the past 20 years since OpenGL was first adopted. And being a cross platform application, there was never any thought about leaving OpenGL. So, why bother even thinking about support for multiple backends and abstraction layers? Plus OpenGL let you get away with mutating the state however you liked, so why not use that power?

Well, by 2018 it was very clear that OpenGL just wasn't cutting it for big applications anymore. It was too far removed from what the hardware was doing, the drivers were huge black boxes and it was all very CPU bound. This was on top of X-Plane being already heavily CPU bound due to the whole simulating airplanes thing that's going on. Also, in the past couple of years it's gotten very clear that single core speed wasn't going to get much faster. But CPUs were going to go even wider and this was yet another headache for OpenGL. Our issue with OpenGL was two-fold: First, we didn't have very good control over the driver. If something suddenly changed, for example because new scenery streamed in, there was a good chance we'd end up with a stutter while the driver compiled new graphics pipelines. Secondly, the driver overhead was enormous! Especially on AMD we saw terrible performance compared to Nvidia on otherwise identical systems. All of that time was spent in the OpenGL driver. This was at a time when we had just adopted VR, which has high demands on framerate. Paired with our goal to not stutter and deliver smooth and consistent FPS to the screen, it was clear that OpenGL had to be replaced.

The modern graphics APIs promised to solve all of our problems. Instead of the driver guessing the workload, you declared it up front. Instead of the driver having to track a ton of state, it became your responsibility. And assuming you know what your application is doing, it might be a lot easier for you to do so. Not to mention the promise of multithreaded rendering. The only downside was that huge parts of X-Plane had to be rewritten from the ground up. There was no concept of command buffers, device queues, graphics pipelines or render passes in the codebase. And because we are shipping on Windows, Linux and macOS we no longer could just pick one modern graphics API and run with it (note that this was long before MoltenVK became even remotely viable). We'd have to do what the cool kids do, write an abstract graphics layer that would translate to Vulkan and Metal under the hood.

