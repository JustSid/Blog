+++
title = "Porting X-Plane to Vulkan and Metal Part #1 - Why bother porting a 20+ year old OpenGL engine?"
date = 2020-01-18T00:00:00+00:00
categories = ["Development", "VIM"]
tags = [ "x-plane", "vulkan", "metal"]
slug = "porting-xplane-part1"
draft = true
+++

This is part 1 of many blog posts detailing basically what I've been up to for the past 2 years. As the title implies, it was porting the engine powering [X-Plane](https://x-plane.com), a professional flight simulator that is currently in version 11 and ships on Windows, macOS and Linux. During the porting effort we shipped 3 large feature and content updates, as well as a ton of smaller bug fix updates. If that doesn't sound exciting enough of a task, we also maintained backwards compatibility for most OpenGL based third party plugins in the modern Vulkan and Metal backends.

In this first post I want to briefly touch on the motivation of porting X-Plane, as well as the broad challenges we were facing and why we wanted to do the port in the first place. The project was underway for 2 years and was mainly done by Ben Supnik (project manager of X-Plane desktop as well as the main graphics guy) and me the "Vulkanologist" at Laminar Research. Of course the rest of the Laminar Research team, while maybe not directly involved in slinging Vulkan and Metal code, were nothing but supportive in our endeavour and are all around great people. Shout out in particular to Tyler Young (who runs our CI and test infrastructure, as well as knows the answers to just about anything related to the codebase), Stefan Riemens (who rewrote a bunch of our shaders and ported a bunch of other misc code) and of course Jennifer Roberts (who does QA amongst a ton of other things).

## Motivation and history

In early 2018, all we had was the legacy X-Plane graphics engine that had grown over the past 20 odd years. And by graphics engine, I mean that we had a bunch of classes to abstract away more complex GL behaviour. Things such as a shader class, a class to handle geometry, an emulation layer for immediate mode rendering that streamed geometry. The typical stuff. Then, we had a ton of OpenGL state whacking all over the codebase. There was no big abstraction over the graphics bits, you either called into one of the helper classes or just called OpenGL directly. Basically, the graphics pieces of X-Plane had grown over the past 20 years since OpenGL was first adopted. And being a cross platform application, there was never any thought about leaving OpenGL. So, why bother even thinking about support for multiple backends and abstraction layers? Plus OpenGL let you get away with mutating the state however you liked, so why not use that power?

Well, by 2018 it was very clear that OpenGL just wasn't cutting it for big applications anymore. It was too far removed from what the hardware was doing, the drivers were huge black boxes and it was all very CPU bound. This was on top of X-Plane being already heavily CPU bound due to the whole simulating airplanes thing that's going on. Also, in the past couple of years it's gotten very clear that single core speed wasn't going to get much faster. But CPUs were going to go even wider and this was yet another headache for OpenGL. Our issue with OpenGL was two-fold: First, we didn't have very good control over the driver. If something suddenly changed, for example because new scenery streamed in, there was a good chance we'd end up with a stutter while the driver compiled new graphics pipelines. Secondly, the driver overhead was enormous! Especially on AMD we saw terrible performance compared to Nvidia on otherwise identical systems. All of that time was spent in the OpenGL driver. This was at a time when we had just adopted VR, which has high demands on framerate. Paired with our goal to not stutter and deliver smooth and consistent FPS to the screen, it was clear that OpenGL had to be replaced.

The modern graphics APIs promised to solve all of our problems. Instead of the driver guessing the workload, you declared it up front. Instead of the driver having to track a ton of state, it became your responsibility. And assuming you know what your application is doing, it might be a lot easier for you to do so. Not to mention the promise of multithreaded rendering. Also on macOS we were stuck on OpenGL 2.1 due to backwards compatibility, so we were locked out of a lot of cool features on the platform. Metal promised us to open the world to such fancy things as viewport layer arrays to render multiple CSM cascades in a single draw call! So clearly, we _had_ to adopt these new amazing APIs!

## Risks

There was some real risk involved however. First of all, Laminar Research is a incredibly small company. We are currently counting 8 programmers on the team and there's just two graphics engine hackers. This meant that it would be a long and drawn out process (hindsight now tells us that it took even longer than anticipated). Additionally, while the graphics stack was being rewritten, we would be unable to work on any big next gen stuff. Essentially the actual eye candy was going to be frozen as is while everything was being rewritten. This had two reasons, first so we can easily test the port against known rendering (X-Plane has deep golden image tests to verify we don't regress rendering). The other reason was that there is no point in writing any new OpenGL code that was essentially obsolete out of the gate, while at the same time the new abstractions weren't done yet. The other really big risk is that X-Plane has a very big add on community and the whole add on market was tailored around OpenGL. Every third party plugin that draws UI or draws a modern cockpit panel uses OpenGL. There was no way we could kill off the third party add on market. Especially because the plugin API is old and companies that made add ons ceased existing (and in some cases the sole authors of plugins have passed away). Maintaining compatibility was hugely important, and also very much at odds with our plans to go to Vulkan and Metal. I'll come back to add on compatibility in its own posts because it was quite a complex process.

In general, a big problem was also the scope of the work, which directly correlated with the amount of time it took. Huge parts of X-Plane had to be rewritten from the ground up. There was no concept of command buffers, device queues, graphics pipelines or render passes in the codebase. And because we are shipping on Windows, Linux and macOS we no longer could just pick one modern graphics API and run with it (note that this was long before MoltenVK became even remotely viable). We'd have to do what the cool kids do, write an abstract graphics layer that would translate to Vulkan and Metal under the hood. Oh, and it also had to deliver on the time investment and beat the current OpenGL implementation. I'm told besides writing a ton of OpenGL and Vulkan extensions, driver writers spend a lot of time on optimizing the drivers. This is like telling your parents that you can live alone and then leave for college only to find out it actually was really nice back home.

## Writing some code

So, this was the situation we were in in 2018 when we decide to actually go ahead with the port for realsis.